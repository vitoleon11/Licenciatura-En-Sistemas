program gork;
type
	rangoAnios = 2015..2024;

	auto = record
		patente : string;
		anio: rangoAnios;
		marca : string;
		color:string;
		modelo:string;
	end;
	
	
	arbol1 = ^nodo1;
	nodo1 = record
		dato : auto;
		hi: arbol1;
		hd : arbol1;
	end;
	lista = ^nodoLista;
	nodoLista = record
		patente : String;
		color :String;
		sig:lista;
	end;
	
	arbol2 = ^nodo2;
	nodo2 = record
		marca:string;
		dato:lista;
		hi:arbol2;
		hd:arbol2;
	end;
	
	listaVector = ^nodoVector;
	nodoVector = record
		dato : auto;
		sig:listaVector;
	end;
	
	vector = array [rangoAnios] of listaVector;
	
		
		
	procedure inicializarVector(var v:vector);
	var
		i : integer;
	begin
		for i := 2015 to 2024 do begin
			v[i] := nil;
		end;
	end;
	procedure leerAuto(var a :auto);
	begin
		writeln('Ingrese una marca');
		readln(a.marca);
		if ( a.marca <> 'MMM') then begin
			writeln('Ingrese una patente');
			readln(a.patente);
			writeln('Ingrese un año');
			readln(a.anio);
			writeln('Ingrese un color');
			readln(a.color);
			writeln('Ingrese un modelo');
			readln(a.modelo);
		end;
	end;

	
	procedure agregarArbol1(var a1:arbol1; var au:auto);
	begin
		if (a1 = nil) then begin
			new(a1);
			a1^.dato := au;
			a1^.hi := nil;
			a1^.hd := nil;
		end
		else if(au.patente <= a1^.dato.patente) then
				agregarArbol1(a1^.hi,au)
			else
				agregarArbol1(a1^.hd,au);
	end;
	
	procedure agregarALista(var l :lista;au:auto);
	var
		nue:lista;
	begin
		new(nue);
		nue^.patente := au.patente;
		nue^.color := au.color;
		nue^.sig := l;
		l:=nue;
	end;
	
	procedure agregarArbol2(var a2 :arbol2;var au:auto);
	begin
		if (a2 = nil) then begin
			new(a2);
			a2^.marca := au.marca;
			agregarALista(a2^.dato,au);
			a2^.hi := nil;
			a2^.hd := nil; 
		end
		else if (au.marca = a2^.marca) then
				agregarALista(a2^.dato,au)
			else if (au.marca < a2^.marca) then
					agregarArbol2(a2^.hi,au)
				else
					agregarArbol2(a2^.hd,au);
	end;

	procedure procesarArboles(var a1:arbol1;var a2:arbol2);
	var
		au:auto;
	begin
		leerAuto(au);
		while (au.marca <> 'MMM') do begin
			agregarArbol1(a1,au);
			agregarArbol2(a2,au);
			leerAuto(au);
		end;
	end;
	
	{EMPIEZA B}
	
	function cantAutosArbol1(a1:arbol1;marca:string):integer;
	begin
		if (a1 = nil) then 
			cantAutosArbol1 := 0
		else if (a1^.dato.marca = marca) then
				cantAutosArbol1 := 1 + cantAutosArbol1(a1^.hi,marca) + cantAutosArbol1(a1^.hd,marca)
			else
				cantAutosArbol1 := cantAutosArbol1(a1^.hi,marca) + cantAutosArbol1(a1^.hd,marca)
	end; 
	{TERMINA B}
	{EMPIEZA C}
	
	function contarLista(l:lista):integer;
	begin
		contarLista := 0;
		while (l <> nil) do begin
			contarLista := contarLista +1;
			l := l^.sig;
		end;
	end;
	
	function cantAutosArbol2(a2:arbol2;marca:string):integer;
	begin
		if (a2 = nil) then
			cantAutosArbol2 := 0
		else if (a2^.marca = marca) then
				cantAutosArbol2 := contarLista(a2^.dato) + cantAutosArbol2(a2^.hi,marca) + cantAutosArbol2(a2^.hd,marca)
			else
				cantAutosArbol2 := cantAutosArbol2(a2^.hi,marca) + cantAutosArbol2(a2^.hd,marca);
	end;
	
	
	
	{TERMINA C}
	{EMPIEZA D}
	procedure insertarALista(var l:listaVector; au:auto);
	var nue:listaVector;
	begin
		new(nue);
		nue^.dato := au;
		nue^.sig := l;
		l := nue;
	end;
	
	procedure agregarAlVector(var v : vector;au:auto);
	begin
		insertarALista(v[au.anio],au);
	end;
	
	procedure procesarVectorPorAnios(var v:vector; a1:arbol1);
	begin
		if (a1 <> nil) then begin
			procesarVectorPorAnios(v,a1^.hi);
			agregarAlVector(v,a1^.dato);
			procesarVectorPorAnios(v,a1^.hd);
		end;
	end;
	{TERMINA D}
	{EMPIEZA E}
	function devolverModelo1(a:arbol1;patente:string):string;
	begin
		if (a = nil) then 
			devolverModelo1 := 'No se encontró'
		else if (a^.dato.patente = patente) then
				devolverModelo1 := a^.dato.modelo
			else if (patente < a^.dato.patente) then	
					devolverModelo1 := devolverModelo1(a^.hi,patente)
				else 
					devolverModelo1 := devolverModelo1(a^.hd,patente);
	end;
	{TERMINA E}
	{EMPIEZA F}
	function buscarEnLista(l:lista;patente:string):string;
	var
		seEncontro : boolean;
	begin
		buscarEnLista := 'No se encontro';
		seEncontro := false;
		while (l <> nil) AND (not seEncontro)do begin
			if (l^.patente = patente) then begin
				buscarEnLista := l^.color;
				seEncontro := true;
			end;
			l := l^.sig;
		end;
	end;
	
	 function devolverColor(a:arbol2; patente:string):string; 
	 begin
		if (a = nil) then
			devolverColor := 'No se encontro'
		else if (buscarEnLista(a^.dato,patente) <> 'No se encontro') then
				devolverColor := buscarEnLista(a^.dato,patente)
			else begin
				devolverColor := devolverColor(a^.hi,patente);
				if (devolverColor = 'No se encontro') then
					devolverColor := devolverColor(a^.hd,patente);
				end;
	 end;
	{TERMINA F}
	
var
	a1:arbol1;
	a2: arbol2;
	v:vector;
	marca:string;
	patente:string;
begin
	a1:=nil;
	a2:= nil;
	procesarArboles(a1,a2);
	read(marca);
	cantAutosArbol1(a1,marca);
	read(marca);
	cantAutosArbol2(a2,marca);
	procesarVectorPorAnios(v,a1);
	read(patente);
	devolverModelo1(a1,patente);
	read(patente);
	devolverColor(a2,patente);
end.

